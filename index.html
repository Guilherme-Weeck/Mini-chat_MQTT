<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>MiniChat MQTT</title>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <style>
    /* ===== Reset & layout ===== */
    html,body { height:100%; margin:0; }
    body {
      margin:0;
      font-family: Arial, sans-serif;
      height:100vh;
      display:flex;
      background:#e5f6ff;
      overflow: hidden; /* important: only #chat scrolls */
    }

    /* Sidebar */
    #sidebar {
      width:280px;
      background:#fff;
      border-right:1px solid #ccc;
      display:flex;
      flex-direction:column;
      z-index:20;
    }
    #user-info {
      padding:12px;
      background:#0099ff; color:white;
      display:flex; justify-content:space-between; align-items:center;
    }
    #conversas { flex:1; overflow-y:auto; }
    .contato { padding:12px 15px; border-bottom:1px solid #eee; cursor:pointer; display:flex; justify-content:space-between; align-items:center; }
    .nome { font-weight:600; }
    .sub { font-size:0.85rem; color:#666; margin-top:4px; }
    .badge { background:red; color:white; border-radius:12px; padding:2px 8px; font-size:0.8rem; }

    /* Main area */
    #main {
      flex:1;
      display:flex;
      flex-direction:column;
      height:100vh;
      overflow: hidden; /* impede body de rolar */
    }
    header {
      flex-shrink: 0;
      background:#0099ff;
      color:white;
      padding:10px;
      display:flex;
      align-items:center;
      position: sticky;
      top: 0;
      z-index: 15;
    }
    #menuBtn, #backBtn { background:none; border:none; font-size:1.5rem; color:white; margin-right:10px; cursor:pointer; }
    #chatTitle { flex:1; font-weight:700; }

    /* Chat area (scrollable) */
    #chat {
      flex:1;
      overflow-y:auto; /* apenas o chat rola */
      padding:14px 10px 80px; /* espa√ßo para input */
      display:flex;
      flex-direction:column;
      background:url('https://www.transparenttextures.com/patterns/grey-jean.png') repeat;
    }

    /* Message bubble */
    .msg {
      max-width:72%;
      margin:6px 0;
      padding:10px 14px;
      border-radius:16px;
      position:relative;
      font-size:1rem;
      line-height:1.25;
      word-break: break-word;
      display:inline-block;
    }
    .me { background:#aee4ff; align-self:flex-end; }
    .other { background:#ddd; align-self:flex-start; }
    .hora { font-size:0.72rem; color:#555; position:absolute; bottom:6px; right:10px; margin-left:6px; }
    .status { font-size:0.72rem; color:#337ab7; position:absolute; bottom:6px; right:40px; } /* ticks for my messages */

    /* Input area (fixed) */
    #inputArea {
      display:flex; align-items:center;
      padding:8px; background:white; border-top:1px solid #ccc;
      position:fixed; bottom:0; left:0; right:0; z-index:30;
    }
    #emojiBtn { background:none; border:none; font-size:1.6rem; cursor:pointer; margin-right:8px; }
    #msg { flex:1; padding:10px 14px; font-size:1rem; border-radius:24px; border:1px solid #ccc; outline:none; }
    #sendBtn { margin-left:8px; padding:10px 14px; border:none; border-radius:20px; background:#0099ff; color:white; font-size:1rem; cursor:pointer; }
    #emojiPicker { position:fixed; bottom:60px; left:10px; right:10px; max-width:420px; margin:auto; background:white; border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,0.15); display:none; padding:8px; z-index:40; flex-wrap:wrap; }
    .emoji { font-size:1.4rem; padding:8px; cursor:pointer; }

    /* New contact area in sidebar */
    #novoContatoWrap { padding:10px; border-bottom:1px solid #ccc; display:flex; gap:8px; }
    #novoContato { flex:1; padding:8px; border-radius:6px; border:1px solid #ccc; }

    /* Responsive: hide sidebar by default on small screens */
    @media (max-width:768px) {
      #sidebar { display:none; position:absolute; left:0; top:0; bottom:0; z-index:50; width:85%; max-width:320px; box-shadow: 2px 0 8px rgba(0,0,0,0.15); }
      #menuBtn { display:inline; }
    }
    @media (min-width:769px) {
      #menuBtn { display:none; }
    }
    .msg-footer {
      display:flex;
      justify-content:flex-end;
      align-items:center;
      gap:4px;  /* espa√ßo entre hora e check */
      font-size:0.72rem;
      color:#555;
      margin-top:4px;
    }

  </style>
</head>
<body>
  <!-- Sidebar -->
  <div id="sidebar" aria-hidden="false">
    <div id="user-info">
      <span id="username">Usu√°rio</span>
      <button onclick="trocarUsuario()" style="background:#ff6666;color:white;border:none;border-radius:8px;padding:6px 8px;cursor:pointer;">Trocar</button>
    </div>

    <!-- Novo contato -->
    <div id="novoContatoWrap">
      <input id="novoContato" placeholder="Novo contato" />
      <button onclick="novoContato()" style="background:#0099ff;color:white;border:none;border-radius:6px;padding:8px 10px;cursor:pointer;">‚ûï</button>
    </div>

    <!-- Lista de conversas -->
    <div id="conversas"></div>
  </div>

  <!-- √Årea principal -->
  <div id="main">
    <header>
      <button id="menuBtn" onclick="toggleSidebar()">‚ò∞</button>
      <button id="backBtn" onclick="fecharConversa()" style="display:none;">‚Üê</button>
      <div id="chatTitle">MiniChat</div>
    </header>

    <div id="chat"></div>

    <!-- Emoji picker -->
    <div id="emojiPicker" aria-hidden="true">
      <!-- lista de emojis comuns -->
      <span class="emoji" onclick="inserirEmoji('üòÄ')">üòÄ</span>
      <span class="emoji" onclick="inserirEmoji('üòÉ')">üòÉ</span>
      <span class="emoji" onclick="inserirEmoji('üòÑ')">üòÑ</span>
      <span class="emoji" onclick="inserirEmoji('üòâ')">üòâ</span>
      <span class="emoji" onclick="inserirEmoji('üòç')">üòç</span>
      <span class="emoji" onclick="inserirEmoji('üòò')">üòò</span>
      <span class="emoji" onclick="inserirEmoji('üòé')">üòé</span>
      <span class="emoji" onclick="inserirEmoji('üòÖ')">üòÖ</span>
      <span class="emoji" onclick="inserirEmoji('ü§£')">ü§£</span>
      <span class="emoji" onclick="inserirEmoji('ü§î')">ü§î</span>
      <span class="emoji" onclick="inserirEmoji('üôå')">üôå</span>
      <span class="emoji" onclick="inserirEmoji('üëç')">üëç</span>
      <span class="emoji" onclick="inserirEmoji('üëé')">üëé</span>
      <span class="emoji" onclick="inserirEmoji('üôè')">üôè</span>
      <span class="emoji" onclick="inserirEmoji('üî•')">üî•</span>
    </div>

    <div id="inputArea">
      <button id="emojiBtn" onclick="toggleEmojiPicker()" aria-label="Abrir emojis">üòÉ</button>
      <input id="msg" placeholder="Digite sua mensagem..." autocomplete="off" />
      <button id="sendBtn" onclick="enviarMensagem()">Enviar</button>
    </div>
  </div>

  <script>
    // ==============================
    // Inicializa√ß√£o
    // ==============================
    let usuario = localStorage.getItem("usuario");
    if (!usuario) {
      usuario = prompt("Digite seu nome de usu√°rio:") || "anonimo_" + Math.floor(Math.random()*1000);
      localStorage.setItem("usuario", usuario);
    }
    document.getElementById("username").textContent = usuario;

    // Dados locais
    let conversas = JSON.parse(localStorage.getItem("conversas") || "[]");
    let historico = JSON.parse(localStorage.getItem("historico") || "{}"); // { contato: [ {id, autor, msg, hora, status} ] }
    let naoLidas = JSON.parse(localStorage.getItem("naoLidas") || "{}");
    let statusUsuarios = {}; // presen√ßa
    let topicoAtual = null;
    let destinoAtual = null;

    // conectar mqtt
    const client = mqtt.connect("wss://broker.hivemq.com:8884/mqtt");

    client.on("connect", () => {
      console.log("conectado");
      client.publish("XzzXminichat2025/presenca/" + usuario, "online", { retain:true });
      client.subscribe("XzzXminichat2025/convites/" + usuario);
      client.subscribe("XzzXminichat2025/presenca/#");
      renderConversas();
      // restore naoLidas and historico variables from storage (already loaded above)
    });

    // ==============================
    // Mensagens recebidas
    // ==============================
    client.on("message", (topic, messageBuf) => {
      const message = messageBuf.toString();
      // convite
      if (topic.startsWith("XzzXminichat2025/convites/")) {
        abrirConversa(message);
        return;
      }
      // presen√ßa
      if (topic.startsWith("XzzXminichat2025/presenca/")) {
        const u = topic.split("/").pop();
        statusUsuarios[u] = message;
        renderConversas();
        return;
      }
      // conversa
      if (topic.startsWith("XzzXminichat2025/usuarios/")) {
        // payload formats:
        // normal message: <autor>|<texto>|<hora>|<msgId>
        // ack message: __ACK__|<type>|<msgId>|<reader>
        const parts = message.split("|");
        const autor = parts[0];
        if (autor === "__ACK__") {
          const tipo = parts[1]; // delivered|read
          const msgId = parts[2];
          const reader = parts[3];
          // atualiza status da mensagem local (se existir)
          marcarStatusLocal(msgId, tipo);
          return;
        }
        const texto = parts[1] || "";
        const hora = parts[2] || new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
        const msgId = parts[3] || (Date.now()+"-"+Math.random().toString(36).slice(2,7));

        // se a mensagem veio de mim mesmo, ignorar (j√° mostrada localmente)
        if (autor === usuario) return;

        // salvar msg vindo de autor
        salvarMensagem(autor, { id: msgId, autor: autor, msg: texto, hora: hora, status: "delivered" });
        // enviar ack de delivered (notifica remetente)
        setTimeout(()=> {
          client.publish(topicoAtual, "__ACK__|delivered|" + msgId + "|" + usuario);
        }, 100);

        if (autor !== destinoAtual) {
          incrementarNaoLidas(autor);
          renderConversas();
          notificarNovaMensagem(autor, texto);
        } else {
          renderHistorico(destinoAtual);
          // j√° que abriu a conversa, enviar read ack
          enviarReadAcksParaContato(autor);
        }
      }
    });

    // ==============================
    // Fun√ß√µes de conversa / UI
    // ==============================
    function iniciarConversa(destino) {
      if (!destino) return;
      abrirConversa(destino);
      client.publish("XzzXminichat2025/convites/" + destino, usuario);
    }

    function abrirConversa(destino) {
      destinoAtual = destino;
      const nomes = [usuario, destino].sort().join("_");
      topicoAtual = `XzzXminichat2025/usuarios/${nomes}`;

      client.subscribe(topicoAtual);
      document.getElementById("chatTitle").textContent = destino + " " + (statusUsuarios[destino]==="online"?"üü¢":"‚ö™");
      document.getElementById("inputArea").style.display = "flex";
      document.getElementById("backBtn").style.display = "inline";
      document.getElementById("menuBtn").style.display = "none";
      renderHistorico(destino);

      if (!conversas.includes(destino)) {
        conversas.push(destino);
        localStorage.setItem("conversas", JSON.stringify(conversas));
      }
      naoLidas[destino] = 0;
      localStorage.setItem("naoLidas", JSON.stringify(naoLidas));
      renderConversas();

      // fechar sidebar no mobile
      if (window.innerWidth <= 768) {
        document.getElementById("sidebar").style.display = "none";
      }

      // enviar read acks (marcar mensagens recebidas como lidas)
      enviarReadAcksParaContato(destino);

      // focus input and scroll to bottom
      setTimeout(()=> { focusInputAndScroll(); }, 200);
    }

    function fecharConversa() {
      destinoAtual = null;
      topicoAtual = null;
      document.getElementById("chatTitle").textContent = "MiniChat";
      document.getElementById("chat").innerHTML = "";
      document.getElementById("inputArea").style.display = "none";
      document.getElementById("backBtn").style.display = "none";
      document.getElementById("menuBtn").style.display = "inline";
    }

    // ==============================
    // Enviar mensagem (com id e hora)
    // ==============================
    function enviarMensagem() {
      const input = document.getElementById("msg");
      const texto = input.value.trim();
      if (!texto || !topicoAtual || !destinoAtual) return;

      const hora = new Date().toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
      const msgId = Date.now() + "-" + Math.random().toString(36).slice(2,7);

      // salvar localmente como 'sent' (aparecer√° no chat)
      salvarMensagem(destinoAtual, { id: msgId, autor: "eu", msg: texto, hora: hora, status: "sent" });
      renderHistorico(destinoAtual);

      // publicar mensagem no t√≥pico: autor|texto|hora|id
      client.publish(topicoAtual, usuario + "|" + texto + "|" + hora + "|" + msgId);

      // manter foco no input (impede teclado de fechar)
      setTimeout(()=> {
        focusInputAndScroll();
      }, 50);
      input.value = "";
    }

    // Enter behaviour: enviar no desktop com Enter (Shift+Enter -> nova linha)
    const msgInput = document.getElementById("msg");
    msgInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        // on mobile Enter sometimes inserts lines; keep behaviour: send on Enter except when Shift held
        e.preventDefault();
        enviarMensagem();
      }
    });

    // quando campo recebe foco, rola para final (evita que teclado esconda √∫ltimas mensagens)
    msgInput.addEventListener("focus", () => {
      setTimeout(()=> {
        const chat = document.getElementById("chat");
        chat.scrollTop = chat.scrollHeight;
      }, 300);
    });

    function focusInputAndScroll() {
      const input = document.getElementById("msg");
      input.focus({preventScroll:true});
      setTimeout(()=> {
        const chat = document.getElementById("chat");
        chat.scrollTop = chat.scrollHeight;
      }, 200);
    }

    // ==============================
    // Persist√™ncia: salvar / render historico
    // ==============================
    function salvarMensagem(contato, msgObj) {
      if (!historico[contato]) historico[contato] = [];
      historico[contato].push(msgObj);
      localStorage.setItem("historico", JSON.stringify(historico));
    }

    function marcarStatusLocal(msgId, tipo) {
      // tipo: delivered | read
      for (const contato in historico) {
        const msgs = historico[contato];
        if (!msgs) continue;
        for (let m of msgs) {
          if (m.id === msgId) {
            if (tipo === "delivered") {
              if (m.status === "sent") m.status = "delivered";
            } else if (tipo === "read") {
              m.status = "read";
            }
            localStorage.setItem("historico", JSON.stringify(historico));
            // se a conversa atual corresponde, re-render
            if (contato === destinoAtual) renderHistorico(destinoAtual);
            return;
          }
        }
      }
    }

    function renderHistorico(contato) {
      const chat = document.getElementById("chat");
      chat.innerHTML = "";
      const msgs = historico[contato] || [];
      msgs.forEach(m => {
        const div = document.createElement("div");
        div.className = "msg " + (m.autor === "eu" ? "me" : "other");

        // corpo do texto
        const corpo = document.createElement("div");
        corpo.textContent = m.msg;

        // rodap√© (hora + status)
        const footer = document.createElement("div");
        footer.className = "msg-footer";

        const hora = document.createElement("span");
        hora.textContent = m.hora;
        footer.appendChild(hora);

        if (m.autor === "eu") {
          const st = document.createElement("span");
          st.textContent = (m.status === "read" ? "‚úì‚úì" : (m.status === "delivered" ? "‚úì" : ""));
          footer.appendChild(st);
        }

        div.appendChild(corpo);
        div.appendChild(footer);
        chat.appendChild(div);
      });
      setTimeout(()=> { chat.scrollTop = chat.scrollHeight; }, 50);
    }


    // escape minimal HTML to prevent injection if someone types <> etc.
    function escapeHtml(str) {
      return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    // ==============================
    // Conversas list / nao lidas
    // ==============================
    function renderConversas() {
      const lista = document.getElementById("conversas");
      lista.innerHTML = "";
      conversas.forEach(c => {
        const div = document.createElement("div");
        div.className = "contato";

        const left = document.createElement("div");
        left.innerHTML = `<div class="nome">${c} ${(statusUsuarios[c]==="online")?"üü¢":"‚ö™"}</div>` +
                          ((historico[c] && historico[c].length) 
                            ? `<div class="sub">${shortPreview(historico[c].slice(-1)[0].msg)}</div>` : "");
        left.style.flex = "1";
        left.onclick = () => abrirConversa(c);

        const right = document.createElement("div");
        right.style.display = "flex";
        right.style.alignItems = "center";
        right.style.gap = "6px";

        if ((naoLidas[c] || 0) > 0) {
          const badge = document.createElement("span");
          badge.className = "badge";
          badge.textContent = naoLidas[c];
          right.appendChild(badge);
        }

        // bot√£o remover
        const btn = document.createElement("button");
        btn.textContent = "‚ùå";
        btn.style.border = "none";
        btn.style.background = "transparent";
        btn.style.cursor = "pointer";
        btn.title = "Remover contato";
        btn.onclick = (e) => {
          e.stopPropagation(); // evita abrir conversa ao clicar
          removerContato(c);
        };
        right.appendChild(btn);

        div.appendChild(left);
        div.appendChild(right);
        lista.appendChild(div);
      });
    }

    function shortPreview(text) {
      if (!text) return "";
      text = text.replace(/\n/g, " ");
      return text.length > 32 ? text.slice(0,29) + "..." : text;
    }

    function incrementarNaoLidas(contato) {
      naoLidas[contato] = (naoLidas[contato] || 0) + 1;
      localStorage.setItem("naoLidas", JSON.stringify(naoLidas));
    }

    // ==============================
    // Notifica√ß√µes
    // ==============================
    function notificarNovaMensagem(remetente, texto) {
      // desktop notifications
      if (Notification.permission === "granted") {
        new Notification("Nova mensagem de " + remetente, { body: texto, icon: "https://cdn-icons-png.flaticon.com/512/1384/1384031.png" });
      } else if (Notification.permission !== "denied") {
        Notification.requestPermission();
      }
      // sound
      try {
        new Audio("https://notificationsounds.com/storage/sounds/file-sounds-1152-pristine.mp3").play();
      } catch (e) { /* ignore */ }
    }

    // ==============================
    // Emoji picker
    // ==============================
    function toggleEmojiPicker() {
      const p = document.getElementById("emojiPicker");
      p.style.display = (p.style.display === "flex" || p.style.display === "block") ? "none" : "flex";
    }
    function inserirEmoji(e) {
      const input = document.getElementById("msg");
      input.value += e;
      input.focus();
      toggleEmojiPicker();
    }

    // helper alias used earlier
    function adicionarEmoji(e){ inserirEmoji(e); }

    // ==============================
    // Sidebar helpers & new contact
    // ==============================
    function toggleSidebar(){
      const sb = document.getElementById("sidebar");
      sb.style.display = (sb.style.display === "block") ? "none" : "block";
    }

    function novoContato() {
      const nome = document.getElementById("novoContato").value.trim();
      if (!nome) return;
      iniciarConversa(nome);
      document.getElementById("novoContato").value = "";
      // fecha sidebar no mobile
      if (window.innerWidth <= 768) toggleSidebar();
    }

    function trocarUsuario() {
      localStorage.clear();
      location.reload();
    }

    // ==============================
    // ACKs: on opening conversation, send read acks for messages addressed to me
    // ==============================
    function enviarReadAcksParaContato(contato) {
      const msgs = historico[contato] || [];
      msgs.forEach(m => {
        if (m.autor !== "eu" && m.status !== "read") {
          // send read ack for the message id
          client.publish(topicoAtual, "__ACK__|read|" + m.id + "|" + usuario);
          // mark locally as read (the sender will receive this and update status)
          m.status = "read";
        }
      });
      localStorage.setItem("historico", JSON.stringify(historico));
      // update UI
      renderHistorico(contato);
    }

    // mark local message statuses when ack arrives
    // (marcarStatusLocal already does this)

    // ==============================
    // Persist initial render
    // ==============================
    renderConversas();

    // ensure correct scrolling behaviour on orientation / resize
    window.addEventListener("resize", () => {
      if (destinoAtual) { setTimeout(()=> { focusInputAndScroll(); }, 200); }
    });

    function removerContato(nome) {
      if (!confirm("Remover contato " + nome + "?")) return;

      conversas = conversas.filter(c => c !== nome);
      delete historico[nome];
      delete naoLidas[nome];

      localStorage.setItem("conversas", JSON.stringify(conversas));
      localStorage.setItem("historico", JSON.stringify(historico));
      localStorage.setItem("naoLidas", JSON.stringify(naoLidas));

      if (destinoAtual === nome) fecharConversa();

      renderConversas();
    }

  </script>
</body>
</html>
